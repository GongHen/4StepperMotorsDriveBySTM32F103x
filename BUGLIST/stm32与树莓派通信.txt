// 我主要是想实现stm32与树莓派进行串口通信

// 一般两块控制芯片通信（主从式）采用的方法（不一定就只能用通信总线）有：
// 1. 串行通信方式；
// 2. 共享内存方式；
// 3. 并行通信方式

// 基本思想有下面这几种：

// 1. 把树莓派串口设置为串口通信模式，树莓派3默认是蓝牙，很折腾人。然后32的TX RX 与树莓派交叉连接，共地就行；
	----> stm32的uart输出电平是TTL电平,3.3V
	----> 树莓派的uart输出电平也是TTL电平，3.3V（查询自网络）
	----> 连线简单

// 2. 树莓派如果自带wifi模块，可以使stm32接wifi模块进行串口通信；
	----> 这他妈就不用连线
	----> 开发效率低（我不会，还得学）

// 3. 树莓派如果自带蓝牙模块（网上查询，好像是树莓派的串口默认指向蓝牙模块），可以使stm32接蓝牙模块进行串口通信；
	----> 同方案2

// 附：stm32自带USB2.0控制器，可以与电脑串口通信，可用于测试

// 选择测试方案1，首先实现stm32与stm32通信

// 硬件接线：主机和从机TXD（Transmit Data）和RXD（Receive Data）交叉互连

// 基本的串口通信程序设计：



// 1. 串口时钟使能，串口是挂载在APB2时钟总线下的外设

// 2. 串口复位

// 3. 串口参数初始化

// 4. 串口使能

// 5. 数据的发送与接收，stm32采用USART_DR寄存器（双寄存器，一个TRD寄存器，一个RDR寄存器，暂存收发数据）
	----> USART_SendData(USARTx,Data);
	----> data = USART_ReceiveData(USART1);

// 6. 读取串口状态（已经开始发送数据/发送完成/接收到数据）
	----> USART_GetFlagStatus(USARTx,USART_SR->TXE/USART_SR->TC/USART_SR->RXEN)
	----> 下一次串口发送操作，一定等待发送缓存器清空（数据已经开始发送）完成之后才能进行
	----> 如果SR中接收状态标志置位，表明接收到来自串口传输的信息,这时才能确认所接收到的信息是什么玩意儿


// 7. 串口中断（一般设置接收数据/发送数据空/发送完成这三个串口中断类型）

// 基本思路（参考stm32串口多处理器通信）：

// 1. 设置A,B两块stm32，A发送地址确认B从机，再发送数据给B，B收到数据后触发串口中断，在中断中处理电机控制信息;
	----> 需要注意，从机要判断接收信息是数据，还是从机地址；
	----> 从机一开始处于静默模式，主机需要时发送指令唤醒从机（地址标记模式WAKE=1,地址匹配）

// 2. 电机运动后，B发送数据给A，A收到数据后触发转口中断，在中断中处理显示信息，显示电机当前运行状态。
	----> USARTx_DR读操作可以将RXNE清0
	----> 设置从机进入地址标记状态，RWU位操作之前，必须RXNE清0;
	----> 即 检测地址 操作分两步：
		1. USART_ReceiveData(USART1);
		2. USART_ReceiverWakeUpCmd(USART1,ENABLE)

// 成功，两块stm32通信成功！！！

// 接下来着手stm32与树莓派通信

// 初步考虑让两者之间按主从方式通信，但是选择不用地址指令连接的模式，因为只有这两者在连接，没有第三者插足

// stm32串口USART多处理器通信有两种方式

// 1. 空闲总线检测（WAKE=0）
	----> 选用这种方式，使用stm32与树莓派通信

// 2. 地址标记检测（WAKE=1）

// 串口一帧包括（如果全设置的话）	一个起始位 + 一个数据字（8/9，MSB可设为奇偶校验位） + 一个停止位

// 基本的思路：

// 1. 主程序初始化串口设置

// 2. 等待串口接收完成中断

// 3. 若接收到数据触发串口中断，在中断服务子程序中将这个接收到的指令判断指令类型之后（根据自定义协议），加入到对应的缓冲区内，如buf[64]

// 4. 主程序中，判断当缓冲区buf[64]不为空时，开始执行步进电机控制程序，直至缓冲区再次为空

// 附：这里串口的优先级要大于定时器的优先级，防止接收到的数据丢失

// 再附附：串口的收发有一个很严重的问题，它存在一定的延迟，当然你可以延时接收，这样也可以减少误码率，但是我这个程序实时性较高，对时间要求较高，所以有点怀疑自己的选择是不是有问题！ 

// 首先与电脑通信调试：

// 1. 发送坐标指令之前一定要先发送 相关指令 将 buf[index] 的索引 index 值复位到 0，这样才能循环进行

// 2. 出现一个问题，这个stm32在接收一组几次操作指令（比方说三组坐标，三次单步操作）之后，完成了这几次单步操作之后，然后不再发送数据，按理来说电机应该不会动作，可是莫名奇妙地每隔几十秒又会按照最后一组坐标，转动电机，只执行电机复位到原点的操作！？？？
	----> 呵呵，我把坐标指令变为一次发送两组，它屁事儿没有
	----> EE 0A 04 07 0A		没有问题(第一个十六进制数为清零标志数据)
	----> EE 0A 04 0E 0E		出现问题
	----> EE 0A 04 07 0A 0E 0E	出现问题
	----> EE 0A 04 0F 0E		没有问题
	----> EF 0A 04 0E 0E		出现问题
	----> FE 0A 04 0E 0E		出现问题
	----> EE 0A 04 0F 0F		出现问题
	----> EE 0A 04 0E 0F		没有问题
	----> EE 0A 04 05 05		出现问题
	----> 呵呵，好像最后一组值不能相同，相同就会出现问题，两个电机只执行复位到原点的操作，持续时间与最后一组值对应
	----> 然后我就让它在执行问题操作之前将当前缓冲区的内容发给电脑，显示 buffer = {00 00 00 00} ,也就是说缓冲区数组buffer是及时清零了的，没有问题，这样一来，能够存储这两个值的只有motor1/2.totalTime了，可以尝试一下，在操作完成后将这两个值清零
	----> 然而并没什么卵用 -_-!
	----> 好吧，我就根本没考虑它们相等的情况，所以在关闭定时器的时候，我就比较两个时间的大小嘛，然后较大的那个来关闭，如果两个相等就一直没关
	----> 程豪琪，煞笔，菜鸡，怒其不争啊，这么简单的bug找半天，不过在结束单步操作时没考虑将电机结构体参数复位，这是犯了很大的错误。
	----> 可以在2018/08/01这天的gihub记录上看到本帅琪这窒息的操作（timer1.c,main.c）。

// stm32与树莓派通信，相关指令协议设置：

// 这样考虑，整个运动过程分为两部分：
	1. 取印章
		----> 树莓派发送印章信息，包括印章id，印章坐标
		      (其实我觉得根本就不用有印章坐标这回事儿，看机械设计的同志怎么搞吧 -|_|- )
		----> stm32接收到信息，筛选出相关指令放入s_buf[30]

		----> XY轴电机根据印章坐标从复位点移动到印章处
		      （其实我觉得印章处就应该放在复位点，方便程序设计，节能，出错率小）
		----> Z轴电机下放，调整位置
		----> 检查当前机械手是否有印章
		----> 有！	
		----> 打开机械手，放回印章
		----> 调整位置，对准目标印章
		----> 没有！
		----> 机械手下放，张开并夹住印章,保持
		----> Z轴电机上抬
		----> XY轴电机回到原点
	2. 执行单步盖章操作
		----> 树莓派发送盖章目标点信息，包括目标点坐标
		----> stm32接收到信息，筛选出相关指令放入buf[30]
		----> 检查是否需要更换印章（需要！执行第1步）
		----> 不需要！
		----> XY轴电机轴根据目标点坐标移动到盖章处
		----> Z轴电机下放，延时盖章，Z轴电机上抬
		----> XY轴电机回到原点

	


	
	
		





