// 树莓派传输指令协议
	0xEE		表示后面的值为目标点坐标值
	0xEF		表示下一操作是否需要更换印章的判断值
	0xFF		表示后面的值为印章坐标值
	0xFx		印章坐标值，x为印章id=0,1,2,3,4,...,E(建议取1~6)
	0x00~0xE9	坐标值（精度要求不高，高8位整数，低8位小数）
	0xED		下一操作是否需要更换印章的判断值为0
	0xEC		下一操作是否需要更换印章的判断值为1
	0xEB		下一操作是否需要更换印章的判断值为11（最开始的第一次操作，一定会先去取印章）
	0xEA		停止指令

// 相关伪代码

// 盖章位置在坐标原点
// 树莓派传输信息示例：
// 0xFF 0xF1,0xF2,0xF3,0xF4	----> s_buf[32] = {0xF1,0xF2,0xF3,0xF4}
// 0xEF,0xEC,0xEC,0xEC,0xEC	----> isNeedChange[32] = {0xEC,0xEC,0xEC,0xEC}
// 0xEE,0x44,0x32,0x55,0x47,0xE4,0x62,0x77,0x22,0xA0,0x00,0xA0,0x00,0x00,0x00,0x29,0x67		
				----> buf[64] = {0x44,0x32,0x55,0x47,0xE4,0x62,0x77,0x22,0xA0,0x00,0xA0,0x00,0x00,0x00,0x29,0x67}
// 0xEA（停止）
// 数组非空时就可以开始电机操作

s_buf[32],buf[32],isNeedChange[32];
	
if Rec == 0xEE				// 准备接收目标点坐标值
	buf_index = 0;
if Rec == 0xEF				// 准备接收下一操作是否需要更换印章的判断值
	inc_index = 0;
if Rec == 0xFF				// 准备接收印章坐标值
	s_buf_index = 0;

if Rec & 0xF0 = 0xF0 && Rec != 0xFF	// 接收印章坐标值
	s_buf[s_buf_index] = Rec;
	s_buf_index ++;
	if(s_buf_index > 32-1)
		s_buf_index = 0;
if Rec == 0xED				// 0xED(don't change) 接收下一操作是否需要更换印章的判断值0
	isNeedChange[isnc_index] = 0;
	isnc_index ++;
	if(isnc_index > 32-1)
		isnc_index = 0;
if Rec == 0xEC				// 0xEC(change) 接收下一操作是否需要更换印章的判断值1
	isNeedChange[isnc_index] = 1;
	isnc_index ++;
	if(isnc_index > 32-1)
		isnc_index = 0;	 
if Rec == 0xEB
	isNeedChange[isnc_index] = 11;	// 0xEB(be obliged to) 接收下一操作是否需要更换印章的判断值11
	isnc_index ++;
	if(isnc_index > 32-1)
		isnc_index = 0;	
if Rec <= 0xE9				// 接收目标点坐标值
	buf[buf_index] = Rex;
	buf_index ++;
	if(buf_index > 64-1)
		buf_index = 0;
if Rec == 0xEA
	isbufNull = 0;			// 检测停止指令，一组指令接收完成，所有数组非空，状态更新
	issbufNull = 0;
	isisncNull = 0;

FF F1 F2 F3 F4 EF ED EC EC EC EE 04 08 05 09 0A 07 05 05

FF F1 F2 F3 F4 EF EB EC EC EC EE 04 08 05 09 0A 07 05 05

FF F1 F1 F1 F1 EF ED ED ED ED EE 04 08 05 09 0A 07 05 05

// 出现问题
FF F1 F1 F1 F1 EF ED EC ED EC EE 04 08 05 09 0A 07 05 05

// 调试接收的每次操作发送给电脑的指令
// all
F1 F1 F1 F1 00 01 00 01 04 08 05 09 0A 07 05 05 
// isNeedChange[]
00 01 00 01 
00 01 00 01 
00 01 00 01 
00 01 00 01
// 可以看出没有清零

// 出现一个问题，就是按照我的逻辑
// 只有执行了取印章的操作id数组和是否更换印章数组当前的元素才会清0
// 实际上， 取印章的操作id数组和是否更换印章数组当前的元素清零是在XY轴动了一次才清0


// 更新指令协议后的测试
FF F1 F1 F1 F1 EF ED EC ED EC EE 44 32 55 47 E4 62 77 22 A0 00 A0 00 00 29 00 67

// 出现问题，当再次发送数据后，一直沿着最后一步循环执行操作
00 00 
00 00 
00 00 
01 01 	// 一步操作结束，可以看到 rec_buffer.isbufNull rec_buffer.issbufNull 都置1了
// 当再次发送数据，XY轴第一次运动，数组接收到数据后isNull位本来都清0了
01 01
00 00 
00 00
00 00
00 01
00 01
00 01

// 我发现我再次发送的时候，XY轴第一次开始运动（isbufNull=0），我让stm32发送当前数组给我
// 00 32 55 47 00 00 00 00 A0 00 A0 00 00 29 00 67 0A[2018-08-03 11:51:51.659]
// (本应是)44 32 55 47 E4 62 77 22 A0 00 A0 00 00 29 00 67
// 也就是说，循环检测数组是不是为空，当再次发送时
// 接收到第一个数据，这时已经满足数组不为空的条件了
// 所以他就不等串口发送完数据，直接跳进去执行XY轴运动，同时继续响应串口中断接收数据
// 所以就出现这种情况

// 解决办法呢，我吃个饭想了一下，设置一个停止指令，等一组控制指令接收完毕之后，再将rec_buffer.isbufNull rec_buffer.issbufNull 都清0
// 更新指令协议后的测试
FF F1 F1 F1 F1 EF ED EC ED EC EE 44 32 55 47 E4 62 77 22 A0 00 A0 00 00 29 00 67 EA
// 每次数组清零时检测一下下一次数组是否为空

// coding:
// 串口缓冲区当前目标点坐标指令清0
rec_buffer.buf[i] = 0; rec_buffer.buf[i+1] = 0; rec_buffer.buf[i+2] = 0; rec_buffer.buf[i+3] = 0;	
// XY轴动了一次，代表着下一次检索 sbuf 和 isNeedChange 的下一个元素
rec_buffer.sbuf[k] = 0;						// 串口缓冲区当前印章ID指令清0
rec_buffer.isNeedChange[k] = 0;				// 串口缓冲区当前操作是否需要更换印章指令清0
// 检查缓冲区数组是否为空
rec_buffer.isbufNull = Check_Null_Buffer(rec_buffer.buf_id);
rec_buffer.issbufNull = Check_Null_Buffer(rec_buffer.sbuf_id);

// 测试结果，数组buf，每一次单步操作启动后发回
// buf = EE 44 32 55 47 E4 62 77 22 A0 00 A0 00 00 29 00 67 EA
00 00 00 00 E4 62 77 22 A0 00 A0 00 00 29 00 67 0A[2018-08-03 02:28:44.711]
00 00 00 00 00 00 00 00 A0 00 A0 00 00 29 00 67 0A[2018-08-03 02:29:09.882]
00 00 00 00 00 00 00 00 00 00 00 00 00 29 00 67 0A[2018-08-03 02:29:47.011]
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0A[2018-08-03 02:30:21.090]
00 00 00 00 E4 62 77 22 A0 00 A0 00 00 29 00 67 0A[2018-08-03 02:31:01.189]
00 00 00 00 00 00 00 00 A0 00 A0 00 00 29 00 67 0A[2018-08-03 02:31:26.359]
00 00 00 00 00 00 00 00 00 00 00 00 00 29 00 67 0A[2018-08-03 02:32:03.489]
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0A[2018-08-03 02:32:37.568]
00 00 00 00 E4 62 77 22 A0 00 A0 00 00 29 00 67 0A[2018-08-03 02:36:09.377]
00 00 00 00 00 00 00 00 A0 00 A0 00 00 29 00 67 0A[2018-08-03 02:36:34.553]
00 00 00 00 00 00 00 00 00 00 00 00 00 29 00 67 0A[2018-08-03 02:37:11.677]
 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0A[2018-08-03 02:37:45.756]

