// 为了解决步进电机在稍微高一点的频率PWM驱动下启动时/换向时堵转（失步）的问题
// 考虑采用S型曲线加减速算法

// 低频启动
// 考虑采用细分驱动技术可以大大提高步进电机的步矩分辨率，减小转矩波动，避免低频共振及降低运行噪声 

// 步进电机启动频率：从静止状态,可以实现不失步的起动,所加的最高频率。
// 启动频率和负载和实际工作频率（带负载）有一定的关系，一般取工作频率的20%-60%之间

// 首先设计一个较为简单的测试例程熟悉一下
// 整体思路

// 1. S曲线加速分为两段，即为 0-t_guai,t_guai-t_yunxing 这两段时间，所以加速应该设置两段离散后的频段表，利用拐点频率判断该使用哪一张表（注意：这两段表加加速度相同）

// 2. 得到两个离散化的S曲线加速表:
	> 一个数组const uint16_t InitAccSValue[n_max]={f...f_max}（加速到最大频率），当确定了拐点频率时，我们直接加速到拐点频率处InitAccSVlaue[n_guai]=f_guai;
	> 另一个表实时建立RealAccSValue[n]={f_guai,...,f_yunxing}，是从拐点处加速到运行频率,这里确定电机运行速度后，实时计算出这段表;

// 3. 设定频段驻留时间，也就是离散S曲线加速表中的时间间隔T,加速时间分为两段，利用定时器1，在中断中，修改电机加速过程中当前的频段频率值InitAccSVlaue[i]或RealAccSValue[i]以修改 PSC 的值 

// 4. 加速完成后，按运行频率（速度）转动电机	

// 附： 由于步进电机低频启动，而且运行时噪音蛮大的，所以我在这个例程中将步进电机驱动器A4988细分数设置为1/4（MS1-MS2->010）
// 	----> 1.8°/4 = 0.45°

// 问题：测试启动频率，运行频率等频率的时候，我自己计算的转速与实际转速看起来相差很大
	----> 个人认为是转速没有计算正确，嗯，是我不小心算错了

// 先写个python脚本求这个离散的频段表吧,输出txt文件
import math
import os
def getN(arr, psc, motor_div):
    ret = 72*1000000*(1.8/motor_div)/(arr*psc*6)
    return ret
def getF(arr, psc):
    ret = 72*1000000/(arr*psc)
    return ret

arr = [500, 1000, 1800, 3600, 5400, 7200, 9000, 10800]
psc = [1,2,3,4,10,20,30,40,100,200,300,400,1000,2000,3000,4000,65536]
for i in range(0,8):
    print("* * * *")
    print('\n')
    for j in range(0,17):
        print(i, j, 72*1000000*(1.8/4)/(arr[i]*psc[j]*6))
	print("* * * *")
	print("\n")

// 暂时用sigmod函数来近似生成S型加速表，用这个原始的微积分分段求解，我他妈的程序感觉很烦燥，不想写
      
