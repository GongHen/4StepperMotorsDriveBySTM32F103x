// 1. 任务间通信的管理
		---- 数据结构：事件控制块ECB

// 1.1 什么是 事件 ？
		---- ucosII操作系统中所有的通信信号，即为 事件
		---- 一个任务或者中断服务子程序通过事件控制块可以向另外的任务发送信号（事件！）
		---- 一个任务可以等待另一个任务或ISR给它发送信号
		---- 多个任务可以同时等待同一个事件的发生（发生后，优先级最高的任务得到事件并进入就绪状态）
		ISR(signal) -----> ECB ----> (...wait)Task
		Task(signal) ----> ECB ----> (...wait)Task

		
// 1.2 事件控制块ECB

#if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
typedef struct os_event {
    INT8U    OSEventType;                    /* 事件类型：信号量、邮箱等 */
    void    *OSEventPtr;                     /* 指向消息或消息队列的指针*/
    INT16U   OSEventCnt;                     /* 计数器（当事件是信号量时） */
    OS_PRIO  OSEventGrp;                     /* 等待任务组 */
    OS_PRIO  OSEventTbl[OS_EVENT_TBL_SIZE];  /* 等待任务列表,包含每个正在等待某个事件的任务 */

#if OS_EVENT_NAME_EN > 0u
    INT8U   *OSEventName;
#endif
} OS_EVENT;
#endif		

// 1.3 ECB的管理
		---- 空闲事件控制块链表，OSInit()函数初始化时，所有ECB链接成为一个单向链表
				---- OSEventWaitListInit();	// 创建一个信号量，邮箱或队列消息时，初始化一个事件控制块
				---- OSEventTaskRdy();		// 事件发生时，将等待列表中高优先级的任务置就绪状态
				---- OSEventTaskWait();		// 将任务从就绪表中删除，放置到对应事件的等待任务表中，进入等待状态
				---- OSEventTO();			// 等待超时，将对应任务置为就绪状态
		

// 2. 同步与互斥
		---- 临界区
		---- 信号量
				---- os_cfg.h 文件中 OS_SEM_EN = 1 才能使 ucosII 支持信号量
				---- ECB类型：信号量

// 2.1 为什么操作系统会提供临界区的操作功能？
		---- 当多个任务 同时 共享一个资源时，比方说3个人取10张票，每次只能取一张
		---- 这时需要给这个共享资源 上锁 ，也就是建立临界区，临界区内一次只能有一个任务获取资源
		---- 这就叫任务的 互斥，获取共享资源时不会打挤或出乱
		---- 比方说，不会出现10张票中，两个人取同一张票，或总票数取完后变为负数

// 2.2 ucosII中的临界区
		---- ucosII采用关闭/打开中断的方式来处理临界区代码，实现任务的互斥
				---- OS_ENTER_CRITICAL();
				---- // 某个任务临界区代码（临界资源）
				---- OS_EXIT_CRITICAL();

// 2.3 什么是信号量？
		---- 信号量是操作系统解决资源互斥的一种特殊的机制（P(wait),V(signal)操作编程）
		
		---- 2.3.1 信号量组成
				---- 信号量的计数值（16位）
				---- 对应任务（等待该信号量）所组成的等待任务表
		
		---- 2.3.2 信号量的作用
				---- 实现对共享资源的互斥访问
				---- 实现任取之间的行为同步
		
		---- 2.3.3 信号量系统服务函数
				---- OSSemCreate();				// 创建一个信号量
						---- cnt = 0~65535;		// 信号量的初始计数值赋值
						---- // 从空闲事件控制块链表中得到一个ECB
						---- // 初始化ECB
						---- // 返回指向该ECB的指针
				
				---- OSSemPend();				// 等待一个信号量
						---- // cnt > 0? cnt--;return;
						---- // cnt == 0? doSomething;// 任务进入阻塞状态
						---- OSSched();			// 调度下一个最高优先级的任务运行
				
				---- OSSemPost();				// 发送一个信号量（V(signal)操作编程）
						---- // 检查是否有任务等待该信号量？
						---- if(dont have)cnt + 1; return;
						---- if(has) doSomething; 
						---- // 将优先级啊最高的任务从等待任务列表中删除，使当前任务进入就绪状态
						---- OSSched();
				
				---- OSSemAccept();				// 无等待地请求一个信号量，区别于OSSemPend()
						---- cnt > 0? cnt - 1; return;
						---- cnt == 0? return;	// 不会进入阻塞状态
	
				---- OSSemQuery();				// 查询一个信号量的当前状态
					
// 3. 任务间通信
		---- 邮箱
				---- os_cfg.h 文件中 OS_MBOX_EN = 1 才能使 ucosII 支持邮箱
				---- ECB类型：邮箱，有专用的邮箱控制块OS_MBOX_DATA
		---- 消息队列
				---- os_cfg.h 文件中 OS_Q_EN = 1 才能使 ucosII 支持邮箱
				---- 设置OS_MAX_QS的值来决定系统支持的最多消息队列数
				---- ECB类型：消息队列，有专用的队列控制块OS_Q
		
// 3.1 之前任务之间通过信号量机制已经实现了资源的共享，也算是一种通信了，
// 为什么还要有邮箱、和消息队列机制？
		---- 低级通信
				---- 信号量，比如传递状态或整数值等控制信息
		---- 高级通信
				---- 共享内存、邮箱、消息队列，比如可以传递任意数量的数据

// 3.2 共享内存
		---- ucosII中内存地址空间只有一个，被所有任务所共享，必须使用信号量实现互斥访问
		
// 3.3 邮箱
		---- 一个任务或者中断服务子程序可以通过 邮箱 向另一个任务发送 一个 指针型变量
		---- 该指针指向了一个包含特定“消息”(message)的数据结构
		
		---- 3.3.1 邮箱的两种状态
				---- 满：邮箱包含一个非空指针型变量
				---- 空：邮箱的内容位空指针NULL
		
		---- 3.3.2 邮箱的系统服务
				---- OSMboxCreate();	// 创建一个邮箱
				---- OSMboxPost();		// 发送一个“消息”(message)到邮箱中
				---- OSMboxPend();		// 等待一个邮箱中的“消息”(message)
				---- OSMboxAccept();	// 无等待地请求邮箱“消息”(message)
				---- OSMboxQuery();		// 查询一个邮箱的状态

// 3.4 消息队列	
		---- 使一个任务或者中断服务子程序可以向另一个任务发送 多个 以指针方式定义的变量
		---- 可以看作是多个邮箱组成的数组，只但是数组中每个“消息”(message)共用一个等待任务列表
		
		---- 3.4.1 消息队列的系统服务函数
				---- OSQCreate();		// 创建一个消息队列
				---- OSQPend();			// 等待一个消息队列中的消息
				---- OSQAccept();		// 无等待地请求消息队列中的消息
				---- OSQPost();			// 以FIFO方式向消息队列发送一个消息
				---- OSQPostFront();	// 以LIFO方式向消息队列发送一个消息
				---- OSQFlush();		// 清空一个消息队列
				---- OSQQuery();		// 查询一个消息队列的状态
		

		
		
		
		